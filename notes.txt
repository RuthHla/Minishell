
Parser :

0. Nouvelle srtucture t_command garantissant le bon ordre des tokens
1. Append / HEREDOC / > peuvent commencer en debut de ligne -> il faut une target 
   < peut commencer si chemin targe valide
>> suivi d’un opérateur ou rien au lieu d’un mot : "cat << |" "cat << "  → erreur (a veriifier).
NE pas traier redir et << >> pareil car ??
2. Mots vides
Exemple : echo "" → c’est valide (argument vide).
Donc attention à ne pas jeter les tokens de type LITERAL même si str="".
3. Gerer les unknowns (retourner des erreurs si caracteres non reconnu)
4. Remplacer les variables par les chemins (aller chercher varibale d'environnement)
5. Si une commande NOT_BUILTIN et commande autre que demande par le sujet 
-> return "bash: %s: command not found"
6. Nettoyer minishell.h des fonctions inutilisees


AFFICHER LES ERREURS SUR LA STDERR (fprintf)

Tokenizer -> $"oui"sal  ou   oui$$ --> 1 seul token exigé  




// <!-- Prototype + definition des fonctions autorisees : -->

<!-- 1. GNU Readline -->
char   *readline(const char *prompt);                               // lit une ligne (sans '\n') et renvoie un buffer alloué ou NULL
int     add_history(const char *string);                            // ajoute `string` à l’historique (0 = succès)
void    rl_clear_history(void);                                     // vide l’historique (via stub sur macOS)
int     rl_on_new_line(void);                                       // informe d’un retour à la ligne (0 = succès)
void    rl_replace_line(const char *text, int clear_undo);          // remplace la ligne courante, clear_undo != 0 efface la pile d’undo
int     rl_redisplay(void);                                         // redessine la ligne courante (0 = succès)

<!-- 2. Mémoire & I/O de base -->
int     printf(const char *format, ...);                     // écrit formaté sur stdout, renvoie nb de caractères ou <0
void   *malloc(size_t size);                                 // alloue `size` octets, renvoie pointeur ou NULL
void    free(void *ptr);                                     // libère un bloc alloué
ssize_t write(int fd, const void *buf, size_t count);        // écrit jusqu’à `count` octets sur `fd`, renvoie nb écrits ou -1

<!-- 3. Fichiers & accès -->
int     access(const char *pathname, int mode);                     // teste R_OK/W_OK/X_OK/F_OK (0 = autorisé)
int     open(const char *pathname, int flags, mode_t mode);         // ouvre/crée un fichier, renvoie fd ≥0 ou -1
ssize_t read(int fd, void *buf, size_t count);                      // lit jusqu’à `count` octets de `fd`, renvoie nb lus ou -1
int     close(int fd);                                              // ferme le descripteur `fd` (0 = succès)

<!-- 4. Processus & exécution -->
pid_t   fork(void);                                                           // clone le processus (0 dans le fils, PID dans le père)
pid_t   wait(int *wstatus);                                                   // attend un fils terminé, renvoie PID ou -1
pid_t   waitpid(pid_t pid, int *wstatus, int options);                        // idem pour un PID spécifique (0, PID ou -1)
pid_t   wait3(int *wstatus, int options, struct rusage *rusage);               // wait + collecte de stats, renvoie PID ou -1
pid_t   wait4(pid_t pid, int *wstatus, int options, struct rusage *rusage);    // waitpid + stats
int     execve(const char *pathname, char *const argv[], char *const envp[]);   // remplace le processus (ne revient pas si OK)

<!-- 5. Signaux -->
void   (*signal(int signum, void (*handler)(int)))(int);                                // installe un handler, renvoie l’ancien ou SIG_ERR
int     sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);   // POSIX, 0 = succès
int     sigemptyset(sigset_t *set);                                                     // initialise `set` vide (0 = succès)
int     sigaddset(sigset_t *set, int signum);                                           // ajoute `signum` à `set` (0 = succès)
int     kill(pid_t pid, int sig);                                                       // envoie `sig` à `pid` (0 = succès)

<!-- 6. Terminaison -->
_Noreturn_ void exit(int status);  // termine le processus avec code `status`

<!-- 7. Répertoires & métadonnées -->
char   *getcwd(char *buf, size_t size);                     // récupère le cwd dans `buf` ou NULL
int     chdir(const char *path);                            // change le cwd, 0 = succès
int     stat(const char *pathname, struct stat *statbuf);   // métadonnées, 0 = succès
int     lstat(const char *pathname, struct stat *statbuf);  // idem sans suivre les liens
int     fstat(int fd, struct stat *statbuf);                // métadonnées d’un fd
int     unlink(const char *pathname);                       // supprime le fichier, 0 = succès

<!-- 8. Descripteurs & tubes -->
int     dup(int oldfd);               // duplique `oldfd`, renvoie newfd ou -1
int     dup2(int oldfd, int newfd);   // duplique `oldfd` sur `newfd`
int     pipe(int pipefd[2]);          // crée un tube pipefd[0]=lecture, pipefd[1]=écriture

<!-- 9. Répertoires (dirent) -->
DIR    *opendir(const char *name);           // ouvre un répertoire, renvoie DIR* ou NULL
struct dirent *readdir(DIR *dirp);           // lit l’entrée suivante, NULL en fin
int     closedir(DIR *dirp);                 // ferme le DIR, 0 = succès

<!-- 10. Gestion d’erreur -->
char   *strerror(int errnum);       // chaîne descriptive de `errnum`
void    perror(const char *s);      // affiche `s: <message errno>`

<!-- 11. Terminal & TTY -->
int     isatty(int fd);                                 // 1 si `fd` est un terminal
char   *ttyname(int fd);                                // nom du terminal ou NULL
int     ttyslot(void);                                  // index de l’entrée utmp ou 0
int     ioctl(int fd, unsigned long request, ...);      // contrôle du terminal, 0 = succès

<!-- 12. Environnement -->
char   *getenv(const char *name);           // valeur de `name` ou NULL

<!-- 13. Termios -->
int     tcgetattr(int fd, struct termios *termios_p);                               // lit les attributs, 0 = succès
int     tcsetattr(int fd, int optional_actions, const struct termios *termios_p);   // fixe, 0 = succès

<!-- 14. Termcap -->
int     tgetent(char *bp, const char *name);                  // charge la base termcap (1 = succès)
int     tgetflag(const char *id);                             // lit une capacité booléenne (-1 si absente)
int     tgetnum(const char *id);                              // lit une capacité numérique (-1 si absente)
char   *tgetstr(const char *id, char **area);                 // lit une séquence de contrôle ou NULL
char   *tgoto(const char *cap, int col, int row);             // génère la séquence de positionnement
int     tputs(const char *str, int affcnt, int (*putc)(int)); // affiche `str` via `putc`
                                     

1- “NE pas traiter redir et << >> pareil car ??”
Parce que :

>/>>/< consomment un seul mot (fichier) puis s’arrêtent.

<< déclenche une lecture multi-ligne jusqu’au délimiteur, avec règles d’expansion différentes selon que le délimiteur est quoté ou non.
Implémentation : ton parseur doit avoir un chemin spécifique pour << (stockage du “limiter”, collecte des lignes, gestion des quotes du limiter, éventuel contrôle-C qui doit annuler le heredoc, fichiers temporaires, etc.).

2- “Append / HEREDOC / > peuvent commencer en début de ligne -> il faut une target”
✅ Oui. Début de ligne autorisé. Il faut immédiatement un mot cible (fichier pour >/>>, délimiteur pour <<).
Ex. valides :

>>log echo ok

<<EOF cat (puis lignes, puis EOF)

>out (seul)

“< peut commencer si chemin target valide”
✅ Oui. < input au début est valide ; échoue si input est introuvable.
Ex. :

<input cat ⟶ comme cat <input

<input (seul) ⟶ ouvre/ferme ; échec si le fichier n’existe pas.